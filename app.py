# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Cxfo01YVLOgvJf6HwRNQsUUvBAytVp7R
"""

# app.py
import dash
from dash import dcc, html
from dash.dependencies import Input, Output, State
import pandas as pd
import yfinance as yf
import plotly.graph_objects as go
from sklearn.ensemble import RandomForestClassifier
import random

# ---------- æŠ€è¡“æŒ‡æ¨™ ----------
def add_kdj(df, n=9, k_period=3, d_period=3):
    low_min = df['Low'].rolling(n, min_periods=1).min()
    high_max = df['High'].rolling(n, min_periods=1).max()
    rsv = (df['Close'] - low_min) / (high_max - low_min + 1e-9) * 100
    df['K'] = rsv.ewm(span=k_period, adjust=False).mean()
    df['D'] = df['K'].ewm(span=d_period, adjust=False).mean()
    df['J'] = 3*df['K'] - 2*df['D']
    return df

def add_rsi(df, period=6):
    delta = df['Close'].diff()
    gain = delta.clip(lower=0)
    loss = -delta.clip(upper=0)
    avg_gain = gain.rolling(period, min_periods=1).mean()
    avg_loss = loss.rolling(period, min_periods=1).mean()
    rs = avg_gain / (avg_loss + 1e-10)
    df['RSI'] = 100 - 100/(1+rs)
    return df

def add_macd(df):
    df['EMA_short'] = df['Close'].ewm(span=12, adjust=False).mean()
    df['EMA_long'] = df['Close'].ewm(span=26, adjust=False).mean()
    df['MACD'] = df['EMA_short'] - df['EMA_long']
    df['MACD_signal'] = df['MACD'].ewm(span=9, adjust=False).mean()
    df['MACD_hist'] = df['MACD'] - df['MACD_signal']
    return df

# ---------- æŠ“è³‡æ–™ ----------
def fetch_data(ticker="ETH-USD", period="60d", interval="5m"):
    df = yf.download(ticker, period=period, interval=interval)
    if isinstance(df.columns, pd.MultiIndex):
        df.columns = df.columns.droplevel(1)
    df = add_kdj(df)
    df = add_rsi(df)
    df = add_macd(df)
    df.dropna(inplace=True)
    return df

# ---------- è¨“ç·´ AI ----------
def train_ai(train_df):
    df = train_df.copy()
    df['target'] = (df['Close'].shift(-1) > df['Close']).astype(int)
    df.dropna(subset=['target'], inplace=True)
    feats = ["K","D","J","RSI","MACD","MACD_signal","MACD_hist"]
    X, y = df[feats], df['target']
    model = RandomForestClassifier(n_estimators=80, random_state=42)
    model.fit(X, y)
    return model, feats

# ---------- åˆå§‹åŒ–è³‡æ–™ ----------
full_df = fetch_data()
if len(full_df) < 30:
    raise ValueError("è³‡æ–™ä¸è¶³ï¼Œç„¡æ³•é–‹å§‹éŠæˆ²")

game_start_index = random.randint(0, len(full_df)-30)
game_df = full_df.iloc[game_start_index:game_start_index+30].copy()
train_df = pd.concat([full_df.iloc[:game_start_index], full_df.iloc[game_start_index+30:]])
model, feats = train_ai(train_df)

# ---------- Dash App ----------
app = dash.Dash(__name__)
app.layout = html.Div([
    html.H2("ğŸ’¹ AI vs Human äº¤æ˜“éŠæˆ²"),
    html.Div(id="countdown", style={"fontSize":20, "float":"right"}),
    dcc.Graph(id="candlestick-chart"),
    html.Div([
        html.Button("è²·å…¥ ğŸŸ¢", id="buy-button", n_clicks=0, style={"marginRight":"10px"}),
        html.Button("è³£å‡º ğŸ”´", id="sell-button", n_clicks=0),
        html.Button("ç«‹å³è·³éå€’æ•¸ â©", id="skip-button", n_clicks=0, style={"marginLeft":"30px"}),
    ], style={"margin":"10px 0"}),
    html.Div(id="game-status"),
    dcc.Interval(id="countdown-interval", interval=1000, n_intervals=0, disabled=False),
    dcc.Interval(id="game-interval", interval=5000, n_intervals=0, disabled=True),
    dcc.Store(id="human-cash-store", data=10000.0),
    dcc.Store(id="human-asset-store", data=0.0),
    dcc.Store(id="ai-cash-store", data=10000.0),
    dcc.Store(id="ai-asset-store", data=0.0),
    dcc.Store(id="step-store", data=20),
    dcc.Store(id="countdown-store", data=10),
    dcc.Store(id="game-started-store", data=False)
])

# ---------- å€’æ•¸è¨ˆæ™‚ ----------
@app.callback(
    Output("countdown", "children"),
    Output("countdown-store", "data"),
    Output("countdown-interval", "disabled"),
    Output("game-interval", "disabled"),
    Output("game-started-store", "data"),
    Input("countdown-interval", "n_intervals"),
    Input("skip-button", "n_clicks"),
    State("countdown-store", "data"),
    State("game-started-store", "data")
)
def countdown(n, skip, countdown_val, game_started):
    ctx = dash.callback_context
    if game_started:
        return "", countdown_val, True, False, True

    triggered_id = ctx.triggered[0]['prop_id'].split('.')[0]
    if triggered_id == "skip-button":
        countdown_val = 0
    else:
        countdown_val -= 1

    if countdown_val <= 0:
        return "å€’æ•¸çµæŸï¼éŠæˆ²é–‹å§‹ï¼", 0, True, False, True
    return f"é›¢éŠæˆ²é–‹å§‹é‚„æœ‰ {countdown_val} ç§’", countdown_val, False, True, False

# ---------- éŠæˆ²é€²è¡Œ ----------
@app.callback(
    Output("candlestick-chart", "figure"),
    Output("game-status", "children"),
    Output("human-cash-store", "data"),
    Output("human-asset-store", "data"),
    Output("ai-cash-store", "data"),
    Output("ai-asset-store", "data"),
    Output("step-store", "data"),
    Input("game-interval", "n_intervals"),
    Input("buy-button", "n_clicks"),
    Input("sell-button", "n_clicks"),
    State("human-cash-store", "data"),
    State("human-asset-store", "data"),
    State("ai-cash-store", "data"),
    State("ai-asset-store", "data"),
    State("step-store", "data")
)
def game_tick(n_intervals, buy_clicks, sell_clicks, human_cash, human_asset, ai_cash, ai_asset, step):
    ctx = dash.callback_context
    action = None
    if ctx.triggered:
        prop_id = ctx.triggered[0]['prop_id']
        if "buy-button" in prop_id:
            action = "buy"
        elif "sell-button" in prop_id:
            action = "sell"

    if step >= len(game_df):
        human_value = human_cash + human_asset*game_df.iloc[-1]['Close']
        ai_value = ai_cash + ai_asset*game_df.iloc[-1]['Close']
        winner = "äººé¡" if human_value > ai_value else ("AI" if ai_value > human_value else "å¹³æ‰‹")
        status = f"éŠæˆ²çµæŸï¼äººé¡è³‡ç”¢: {human_value:.2f}, AIè³‡ç”¢: {ai_value:.2f}, è´å®¶: {winner}"
        fig = go.Figure(data=[go.Candlestick(
            x=game_df.index,
            open=game_df['Open'], high=game_df['High'],
            low=game_df['Low'], close=game_df['Close']
        )])
        return fig, status, human_cash, human_asset, ai_cash, ai_asset, step

    current_price = game_df.iloc[step]['Close']

    # ç©å®¶æ“ä½œ
    if action == "buy" and human_cash>0:
        human_asset += human_cash/current_price
        human_cash = 0
    elif action=="sell" and human_asset>0:
        human_cash += human_asset*current_price
        human_asset = 0

    # AI æ“ä½œ
    ai_feats = game_df[feats].iloc[step].to_frame().T
    ai_pred = model.predict(ai_feats)[0]
    if ai_pred==1 and ai_cash>0:
        ai_asset += ai_cash/current_price
        ai_cash=0
    elif ai_pred==0 and ai_asset>0:
        ai_cash += ai_asset*current_price
        ai_asset=0

    # ç•«åœ–
    sub_df = game_df.iloc[:step+1]
    fig = go.Figure(data=[go.Candlestick(
        x=sub_df.index,
        open=sub_df['Open'], high=sub_df['High'],
        low=sub_df['Low'], close=sub_df['Close']
    )])
    status = f"ç¬¬ {step-19+1}/10 æ ¹Kç·šä¸­... ç•¶å‰åƒ¹æ ¼: {current_price:.2f}"
    step += 1

    return fig, status, human_cash, human_asset, ai_cash, ai_asset, step

# ---------- å•Ÿå‹• ----------
if __name__ == "__main__":
    app.run(debug=True, port=8050)